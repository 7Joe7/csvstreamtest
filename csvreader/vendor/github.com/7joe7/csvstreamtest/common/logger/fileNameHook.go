package logger

import (
	"fmt"
	"runtime"
	"strings"
	"sync/atomic"

	"github.com/rs/zerolog"
)

// FileNameHook adds function and line number to the logs of the logger
type FileNameHook struct {
	pretty bool
}

// Run runs the hook
func (h FileNameHook) Run(e *zerolog.Event, level zerolog.Level, msg string) {
	// Run hook if debug or pretty
	if zerolog.Level(atomic.LoadUint32(gLevel)) == zerolog.DebugLevel || h.pretty {
		// Go through the layers of calls
		// We start with 2 because the minimum layer that we
		// are looking for is after the call to Msg() that
		// itself calls this hook.Run() method.
		// 6 layers should be enough to always find the
		// call to Msg()
		for lvl := 2; lvl < 6; lvl++ {
			_, file, line, _ := runtime.Caller(lvl)

			// Filter out the internal calls within zerolog
			if strings.Contains(file, "vendor/github.com/rs/zerolog") ||
				strings.Contains(file, "common/infrastructure/logger/zerolog.go") ||
				strings.Contains(file, "libellula/infrastructure/logger/zerolog.go") ||
				strings.Contains(file, "autogenerated") {
				continue
			}

			// keep only filename and not full path in pretty mode
			if h.pretty {
				fileIdx := strings.LastIndex(file, "/") + 1
				file = file[fileIdx:]
			}

			// ex: thumbsnail:l34
			location := fmt.Sprintf("%s:%d", file, line)
			e.Str("location", location)
			break
		}
	}
}
